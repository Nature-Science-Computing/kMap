# Development Guide

This is a small guide on how to develop a generic new feature for
kMap.py. Obviously, this guide is not and can not be extensive, but
is intended to give a rough overview of some the underlying design and code principles used to develop most features currently present.

It is assumed that the reader has a basic understanding of object-
orientated programming, Qt (PyQt) and python.
As is best practice in open-source python code this project follows the PEP8 coding standard guidelines. A copy can be found in the /docs/styleguide folder and it would be highly appreciated if this standard is followed by all contributors.

## Structure

A generic feature in kMap.py usually consists of three parts (MVC):
- a controller class
- a model class
- a .ui design file

although a lot of features do not actually require a model class and only classes with GUI components require a .ui file.

## Model Class

Best practice is to start with the model class. It is necessary for all features performing calculation or handling complex or large data as this code that should be encapsulated from other parts. The file containing the class should carry the name of the feature followed by "_model" and the class itself should also be named by the feature followed by "Model".

This class should be written without the GUI or even other features or components in mind. It should be entirely formed by the data or calculation and only provide an easy to use and generic interface to it.
If the feature does not handle any data or perform any calculations this class can be skipped and all the minor things integrated into the controller class.

## .ui File

This file is auto-generated by the QtCreator program and contains everything (possible) defining the GUI. This file can be parsed by the controller class to circumvent the need for writing GUI definition code manually.

QtCreator is a program available under an open-source license and with it, one can simply drag and drop GUI components. For more information on how to use it please refer to tutorials available online.

It is advised each component gets a descriptive name (objectName) which it is referred by inside the controller class. For features with multiple GUI components please consider grouping them into a QGroupBox if possible.

Please also note and make use of the "Promote to..." feature. This way a generic QWidget in QtCreator can be set to a custom class inheriting from QWidget without actually defining the class inside the .ui file. However, this feature does not permit parameters being passed to the class initialization and thus can not always be used. Those are the rare cases in which GUI defining code has to be put into the controller class.

This file should be saved with the feature's name and a .ui ending into the kmap/ui directory.
This way almost all GUI definitions can be done outside the code which results in a much cleaner and easier to read code.

## Controller Class

This class is the heart of the feature and pretty much no feature works without one. It ties the interface provided by the model, the GUI defined by the .ui file together and handles all interaction with the "outside world". This class is class contains the business logic, signals and slots, the initialization of the feature and an interface for other features to use.

Here is a template for such a class Foo which should be followed as much as possible:


    # PyQt5 Imports
    from PyQt5 import uic
    from PyQt5.QtCore import pyqtSignal, QDir
    from PyQt5.QtWidgets import QWidget

    # Own Imports
    from kmap import __directory__

    # Load .ui File
    UI_file = __directory__ + QDir.toNativeSeparators('/ui/foo.ui')
    Foo_UI, _ = uic.loadUiType(UI_file)


    class Foo(QWidget, Foo_UI):
        
        # Signals go here
        signal1_triggered = pyqtSignal()

        def __init__(self, *args, **kwargs):

            # Pre initialization code (e.g. setting variables) go here

            # Setup GUI
            super(Foo, self).__init__(*args, **kwargs)
            self.setupUi(self)

            self._setup()
            self._connect()

        def _setup(self):
            pass

        def _connect(self):
            pass

Going from the top to bottom through the code:

### Imports

As usual place all your imports here. The imports of "uic", "QDir" and "pyqtSignal" are necessary if your feature has a GUI component realized as a .ui file. The import of "QWidget" can either be dropped if your feature does not have any GUI representation at all or be replaced by a child class of QWidget if it suits your feature better (e.g. QMainWindow).

The import of "__directory__" is used to find the .ui file. It is highly recommended to set any path as a relative path starting from the path defined by __directory__ (inside the kmap folder).

### Loading the .ui File
Those two lines can be copy-pasted into any feature with a .ui file to import it. Replace "Foo" and "foo" by your features name.

### Class Definition
As you can see, the controller class inherits from QWidget (or QMainWindow) and from the class created by the .ui file. Note: The order of inheritance is not arbitrary!
The class also contains all signals as class-wide variables. If your class does not need signals also drop the pyqtSignal import at the top.

### Initialization
The class can have arbitrary arguments in its init method, however, please note that this makes it impossible for QtCreator to promote QWidgets to this class. Other features will have to include your feature manually into their GUI if necessary. Thus it should be avoided if possible.

Next can be some minor code necessary to be done before all the actual initialization. This usually includes settings some variables from the parsed arguments necessary in the init process.

The next two lines can be copy-pasted if your feature uses a .ui file. They initialize the GUI.

Next are calls to two methods all features should or can have. The "_setup" method should be used to do other initialization processes necessary. This usually includes the manual definition of GUI elements not possible by the .ui file or populating tables and combo boxes. 

Last is the "_connect" method. It should be used to connect all the signals from your GUI components to the according slots (methods) in your class.
DO NOT connect to signals of GUI components of other features directly! Instead, define your own signals inside the feature others can connect to. You can directly parse signals like this:
    self.your_gui_component.its_signal.connect(self.your_signal.emit)
DO NOT use lambda expressions to add variables to already existing signals. This can prevent your class from being correctly collected by the GC and thus leads to a memory leak.

### Rest of the class

The rest of the class should consist of public methods providing an easy interface to your feature and private methods to do the business logic and interact with the GUI or the model class.

